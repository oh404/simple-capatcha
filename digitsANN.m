clc; clear all; close all; % cleaning all previous values

% loading target values;
targetvals = csvread('targetvals.csv');

%% TRAINING:

% loading train image:
I = imread('digits/train2.jpg');

% cleaning and making it BW:
BW = createMask(I);

% applying regionprops, numbering all objects with area higher than 50px:
[labels, number] = bwlabel(BW);
Istats = regionprops(labels);
Istats( [Istats.Area] < 50 ) = [];
% recording the number of objects:
num = length(Istats);

% recording 4 objects:
Ibox = floor( [Istats.BoundingBox] );
Ibox = reshape(Ibox, [4 num]);

% showing the image:
figure, imshow(BW); 
hold on
for k = 1 : num
    % for each of the object (digit) creating a subimage, and recording it
    % to separate image with 24x12 size. Drawing a boundingboxes of each
    % objects:
    rectangle('position', Ibox(:,k), 'edgecolor', 'r', 'LineWidth', 2);
    
    % calculating objects positions:
    col1 = Ibox(1, k);
    col2 = col1 + Ibox(3, k);
    row1 = Ibox(2, k);
    row2 = row1 + Ibox(4, k);
    
    subImage = BW(row1:row2, col1:col2);
    templateImageResized = imresize(subImage, [24 12]);
    
    % moving resized objects to TTraining matrix, for training on ANN:    
    TTraining(k,:) = templateImageResized(:)';
end
hold off

% TTarget, where all target values for training will be kept (0-9):
TTarget = zeros(100,10);

for row = 1:10
    for col = 1:10
        TTarget( 10 * (row-1) + col, row ) = 1;
    end
end

% transposing to make the same-dimensioned:
TTraining = TTraining';
TTarget = TTarget';

% new ANN with 2 layers of 64-neurons each, logsig:
net = newff([zeros(288,1) ones(288,1)], [256 256 10], {'logsig' 'logsig' 'logsig'}, 'traingdx');
net = train(net, TTraining, TTarget); 

%% TESTING:

% testing on 50 images:
for i = 1:50
    % cleaning the buffer after each iteration:
    TPattern = [];
    subImage = [];
    subImageResized = [];
    
    % reading the image:
    I = imread(strcat('digits/',string(i),'.jpg'));
    
    % cleaning the image:
    BW = createMasktest(I);
    BW2 = imclearborder(BW, 4);
    
    % applying regionprops to number the objects (digits) with area > 50px:
    [labels, number] = bwlabel(BW2);
    Istats = regionprops(labels); 
    Istats( [Istats.Area] < 50 ) = [];
    num = length(Istats); 
    
    Ibox = floor( [Istats.BoundingBox] );
    Ibox = reshape(Ibox, [4 num]);

    % these two lines can be commented for faster running, without showing each image:
    figure
    imshow(BW2); 
    hold on
    for k = 1 : num
        % drawing bouding boxes for each of the separate objects:
        rectangle('position', Ibox(:,k), 'edgecolor', 'r', 'LineWidth', 3);

        col1 = Ibox(1, k);
        col2 = col1 + Ibox(3, k);
        row1 = Ibox(2, k);
        row2 = row1 + Ibox(4, k);
        
        % keeping subimages:
        subImage = BW2(row1:row2, col1:col2);
        subImageResized = imresize(subImage, [24 12]);
        
        % keepping patterns of the resized 24x12 images for recognition on
        % ANN:
        TPattern(k,:) = subImageResized(:)';
    end
    hold off
    
    % recognizing the images:
    TPattern = TPattern';
    Y = sim(net, TPattern);
    [value index] = max(Y);
    
    % since we have 10 digits from 0-9, recuding 1 from index will give our target values
    digits = index - 1; 
    results(i,:) = digits % keeping all results
end 

%% Accuracy
% comparting target values and recognized values:
a = results == targetvals;
% calulating accuracy by % with the number of correctly recognized digits
% by the total number of digits
acc = sum(sum(a))/numel(a);
disp('Accuracy:')
disp(acc);

%% Masks from Color Tresholder

function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 29-Nov-2021
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.004;
channel1Max = 0.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 0.876;

% Create mask based on chosen histogram thresholds
sliderBW = ( (I(:,:,1) >= channel1Min) | (I(:,:,1) <= channel1Max) ) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end


%% for test

function [BW,maskedRGBImage] = createMasktest(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 29-Nov-2021
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.000;
channel1Max = 0.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 0.322;

% Create mask based on chosen histogram thresholds
sliderBW = ( (I(:,:,1) >= channel1Min) | (I(:,:,1) <= channel1Max) ) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end
